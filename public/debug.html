<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Homies Chat - Debug Mode</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/dm-friends.css">
    <link rel="stylesheet" href="css/friends.css">
    <link rel="stylesheet" href="css/app-icon.css">
    <link rel="stylesheet" href="css/message-menu.css">
    <link rel="icon" href="favicon.png" type="image/png">
    <style>
        /* Critical overrides to force visibility */
        body {
            overflow: auto !important;
            background-color: #1a2633 !important;
        }
        
        #chat-container {
            display: grid !important;
            grid-template-columns: 280px 1fr !important;
            grid-template-areas: "sidebar content" !important;
            height: 100vh !important;
            width: 100% !important;
            background-color: #1a2633 !important;
            position: relative !important;
            z-index: 10 !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }
        
        #left-sidebar {
            grid-area: sidebar !important;
            display: flex !important;
            flex-direction: column !important;
            background-color: #1a2633 !important;
            height: 100vh !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
            z-index: 20 !important;
        }
        
        #main-content {
            grid-area: content !important;
            display: flex !important;
            flex-direction: column !important;
            background-color: #121212 !important;
            height: 100vh !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
            z-index: 20 !important;
        }
        
        /* Hide all auth screens */
        #auth-container, .login-container, #login-container {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none !important;
            z-index: -1 !important;
        }
        
        /* Make sure elements are clickable */
        button, a, input, textarea {
            pointer-events: auto !important;
            cursor: pointer !important;
        }
        
        /* Force showing chat components */
        #messages-container, #message-input-area, #chat-header {
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* Fix message styling */
        .message {
            display: flex;
            align-items: flex-start;
            margin-bottom: 16px;
            padding: 4px 20px;
            transition: background-color 0.2s;
        }
        
        .message:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .message-avatar {
            width: 40px;
            height: 40px;
            min-width: 40px;
            margin-right: 16px;
            border-radius: 50%;
            overflow: hidden;
        }
        
        .message-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .message-content {
            flex: 1;
            min-width: 0;
        }
        
        .message-header {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .message-author {
            font-weight: 600;
            margin-right: 8px;
            color: var(--primary-color);
        }
        
        .message-timestamp {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .message-text {
            color: var(--text-light);
            word-break: break-word;
            line-height: 1.4;
        }
        
        /* Fix messages container */
        #messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px 0;
            display: flex !important;
            flex-direction: column !important;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <!-- Main App - Discord Layout -->
        <div id="chat-container" style="display: grid !important;">
            
            <!-- Left Sidebar -->
            <div id="left-sidebar" style="display: flex !important;">
                <!-- App Logo -->
                <div class="app-logo">
                    <img src="https://cdn.glitch.global/2ac452ce-4fe9-49bc-bef8-47241df17d07/default%20pic.png?v=1747408645553" alt="The Homies Chat" class="app-icon">
                    <span>The Homies Chat</span>
                </div>
                
                <!-- Main Navigation -->
                <div class="main-nav">
                    <button class="nav-button active" id="home-button" title="Home">
                        <i class="bi bi-house-fill"></i>
                        <span>Home</span>
                    </button>
                    <button class="nav-button" id="dm-button" title="Direct Messages">
                        <i class="bi bi-chat-fill"></i>
                        <span>DMs</span>
                    </button>
                </div>
                
                <!-- Channels Section -->
                <div id="channels-section">
                    <div class="section-header">
                        <span>CHANNELS</span>
                        <button id="add-channel-btn" class="btn-icon" title="Add Channel">
                            <i class="bi bi-plus-lg"></i>
                        </button>
                    </div>
                    <div id="channels-list" class="list-container">
                        <div class="list-item active" data-channel="general">
                            <i class="bi bi-hash"></i>
                            <span>general</span>
                        </div>
                        <div class="list-item" data-channel="announcements">
                            <i class="bi bi-hash"></i>
                            <span>announcements</span>
                        </div>
                        <div class="list-item" data-channel="memes">
                            <i class="bi bi-hash"></i>
                            <span>memes</span>
                        </div>
                    </div>
                </div>
                
                <!-- User Profile Area -->
                <div class="user-profile-area">
                    <div class="user-avatar">
                        <img src="https://cdn.glitch.global/2ac452ce-4fe9-49bc-bef8-47241df17d07/default%20pic.png?v=1744642336378" alt="Your Avatar">
                        <div class="user-status online"></div>
                    </div>
                    <div class="user-details">
                        <div class="user-name" id="current-user">Etherwolf</div>
                    </div>
                    <div class="user-controls">
                        <button class="user-control-button" id="settings-button" title="Settings">
                            <i class="bi bi-gear-fill"></i>
                        </button>
                        <button class="user-control-button" id="logout-btn" title="Logout">
                            <i class="bi bi-box-arrow-right"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Main Content Area (Right) -->
            <div id="main-content" style="display: flex !important;">
                <!-- Chat Header -->
                <div id="chat-header">
                    <div class="d-flex align-items-center">
                        <i class="bi bi-hash me-2"></i>
                        <span class="fw-bold" id="chat-title">general</span>
                    </div>
                    <div class="header-controls">
                        <!-- Video call button removed as requested -->
                    </div>
                </div>

                <!-- Messages Container -->
                <div id="messages-container">
                    <!-- Messages will be loaded here by JS -->
                    <div class="date-separator">
                        <span>Today</span>
                    </div>
                    <div class="system-message">
                        Welcome to the beginning of #general
                    </div>
                    <!-- Debug message -->
                    <div class="message">
                        <div class="message-avatar">
                            <img src="https://cdn.glitch.global/2ac452ce-4fe9-49bc-bef8-47241df17d07/default%20pic.png?v=1746110048911" alt="System">
                        </div>
                        <div class="message-content">
                            <div class="message-header">
                                <span class="message-author">System</span>
                                <span class="message-timestamp">Just now</span>
                            </div>
                            <div class="message-text">
                                Debug mode active. This is a special debug version to help fix display issues.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Message Input Area -->
                <div id="message-input-area">
                    <div class="message-input-container" style="width: 100%;">
                        <div class="input-wrapper" style="width: 100%;">
                            <textarea id="message-input" placeholder="Message #general" rows="2" style="width: 100%; min-height: 60px; padding: 10px; font-size: 16px;"></textarea>
                        </div>
                        <div class="message-controls">
                            <button class="message-control-button" id="emoji-button" title="Add Emoji">
                                <i class="bi bi-emoji-smile"></i>
                            </button>
                            <button class="message-control-button" id="attach-file-button" title="Attach File">
                                <i class="bi bi-paperclip"></i>
                            </button>
                            <button id="send-button" title="Send Message">
                                <i class="bi bi-send-fill"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <!-- Third-party libraries -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    
    <!-- Supabase Credentials -->
    <script>
        // Global Supabase configuration
        window.SUPABASE_URL = 'https://xjgufysdlxwauocezfut.supabase.co';
        window.SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZ3VmeXNkbHh3YXVvY2V6ZnV0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MDk5OTc5MzcsImV4cCI6MjAyNTU3MzkzN30.6tORnBIq_D0IvBo11ZtJcxJ48QKv5qwZJJIEerIgcps';
        window.SUPABASE_SERVICE_KEY = window.SUPABASE_ANON_KEY; // Will be replaced with actual service key if available
        window.JWT_SECRET = ''; // Will be set if available
    </script>

    <!-- Authentication scripts -->
    <script>
        // Check for existing authentication or perform login
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Debug mode active - checking authentication');
            
            // Display loading message while we check auth
            const body = document.body;
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'loading-overlay';
            loadingOverlay.style.position = 'fixed';
            loadingOverlay.style.top = '0';
            loadingOverlay.style.left = '0';
            loadingOverlay.style.width = '100%';
            loadingOverlay.style.height = '100%';
            loadingOverlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
            loadingOverlay.style.display = 'flex';
            loadingOverlay.style.justifyContent = 'center';
            loadingOverlay.style.alignItems = 'center';
            loadingOverlay.style.zIndex = '9999';
            loadingOverlay.style.flexDirection = 'column';
            loadingOverlay.innerHTML = `
                <h2 style="color: white; margin-bottom: 20px;">Initializing Debug Mode...</h2>
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p id="loading-message" style="color: white; margin-top: 20px;">Checking authentication...</p>
            `;
            body.appendChild(loadingOverlay);
            
            // Function to update loading message
            function updateLoadingMessage(message) {
                document.getElementById('loading-message').textContent = message;
            }
            
            // Check for existing auth in localStorage
            const storedUser = localStorage.getItem('user');
            const authToken = localStorage.getItem('auth_token');
            
            if (storedUser && authToken) {
                try {
                    const user = JSON.parse(storedUser);
                    
                    // Clear stored authentication if this is a fresh debug session
                    if (window.location.href.includes('?clear=true')) {
                        localStorage.removeItem('user');
                        localStorage.removeItem('auth_token');
                        throw new Error('Clearing stored authentication');
                    }
                    
                    console.log('Found stored authentication', user.username);
                    updateLoadingMessage(`Found stored authentication for ${user.username}`);
                    
                    // Create socket connection with auth
                    window.socket = io({
                        auth: {
                            token: authToken,
                            userData: user
                        },
                        query: {
                            token: authToken,
                            userId: user.id || '',
                            username: user.username || ''
                        }
                    });
                    
                    // Listen for socket connection
                    window.socket.on('connect', function() {
                        console.log('Socket connected, registering session');
                        updateLoadingMessage('Socket connected, initializing interface...');
                        
                        // Register session
                        window.socket.emit('register-session', user);
                        
                        // Show the chat interface
                        setTimeout(() => {
                            initDebugInterface(user);
                            loadingOverlay.remove();
                        }, 1000);
                    });
                    
                    // Handle connection error
                    window.socket.on('connect_error', function(error) {
                        console.error('Socket connection error:', error);
                        updateLoadingMessage('Connection error, falling back to debug mode...');
                        
                        // Show interface anyway after delay
                        setTimeout(() => {
                            initDebugInterface(user);
                            loadingOverlay.remove();
                        }, 2000);
                    });
                } catch (e) {
                    console.error('Error parsing stored user:', e);
                    showLoginForm();
                }
            } else {
                // No stored authentication, show login form
                updateLoadingMessage('No stored authentication, please log in');
                setTimeout(() => {
                    showLoginForm();
                }, 1000);
            }
            
            // Function to show login form
            function showLoginForm() {
                loadingOverlay.remove();
                
                // Create login form overlay
                const loginOverlay = document.createElement('div');
                loginOverlay.id = 'login-overlay';
                loginOverlay.style.position = 'fixed';
                loginOverlay.style.top = '0';
                loginOverlay.style.left = '0';
                loginOverlay.style.width = '100%';
                loginOverlay.style.height = '100%';
                loginOverlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
                loginOverlay.style.display = 'flex';
                loginOverlay.style.justifyContent = 'center';
                loginOverlay.style.alignItems = 'center';
                loginOverlay.style.zIndex = '9999';
                
                loginOverlay.innerHTML = `
                    <div class="card" style="width: 400px;">
                        <div class="card-header bg-primary text-white text-center">
                            <h4>Debug Mode Login</h4>
                        </div>
                        <div class="card-body">
                            <form id="debug-login-form">
                                <div class="mb-3">
                                    <label for="username" class="form-label">Username</label>
                                    <input type="text" class="form-control" id="username" placeholder="Enter your username">
                                </div>
                                <div class="mb-3">
                                    <label for="password" class="form-label">Password</label>
                                    <input type="password" class="form-control" id="password" placeholder="Enter your password">
                                </div>
                                <div class="mb-3">
                                    <label for="avatar-url" class="form-label">Avatar URL (optional)</label>
                                    <input type="text" class="form-control" id="avatar-url" placeholder="URL to your avatar image">
                                    <div class="form-text">Leave blank to use default avatar</div>
                                </div>
                                <div id="login-error" class="alert alert-danger d-none"></div>
                                <button type="submit" class="btn btn-primary w-100">Login</button>
                            </form>
                        </div>
                    </div>
                `;
                
                body.appendChild(loginOverlay);
                
                // Set up login form submission
                document.getElementById('debug-login-form').addEventListener('submit', function(e) {
                    e.preventDefault();
                    
                    const username = document.getElementById('username').value;
                    const password = document.getElementById('password').value;
                    
                    if (!username || !password) {
                        showLoginError('Username and password are required');
                        return;
                    }
                    
                    // Show loading message
                    document.querySelector('#debug-login-form button').innerHTML = `
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        Logging in...
                    `;
                    
                    const avatarUrl = document.getElementById('avatar-url').value.trim();
                    
                    // Attempt login
                    fetch('/api/auth/signin', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ username, password }),
                        credentials: 'include'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.ok && data.user) {
                            // Add avatar URL if provided
                            if (avatarUrl) {
                                data.user.avatarUrl = avatarUrl;
                                data.user.avatar_url = avatarUrl;
                            }
                            
                            // Store authentication
                            localStorage.setItem('user', JSON.stringify(data.user));
                            localStorage.setItem('auth_token', data.token || '');
                            
                            // Create socket connection
                            window.socket = io({
                                auth: {
                                    token: data.token || '',
                                    userData: data.user
                                },
                                query: {
                                    token: data.token || '',
                                    userId: data.user.id || '',
                                    username: data.user.username || ''
                                }
                            });
                            
                            // Register session
                            window.socket.emit('register-session', data.user);
                            
                            // Remove login overlay and show interface
                            loginOverlay.remove();
                            initDebugInterface(data.user);
                        } else {
                            showLoginError(data.error || 'Login failed');
                            document.querySelector('#debug-login-form button').textContent = 'Login';
                        }
                    })
                    .catch(error => {
                        console.error('Login error:', error);
                        showLoginError('An error occurred during login');
                        document.querySelector('#debug-login-form button').textContent = 'Login';
                    });
                });
                
                // Helper to show login errors
                function showLoginError(message) {
                    const errorElement = document.getElementById('login-error');
                    errorElement.textContent = message;
                    errorElement.classList.remove('d-none');
                }
            }
        });
        
        // Function to initialize the debug interface
        function initDebugInterface(user) {
            console.log('Initializing debug interface for user:', user.username);
            
            // Make sure chat container is visible
            const chatContainer = document.getElementById('chat-container');
            if (chatContainer) {
                chatContainer.style.display = 'grid';
                chatContainer.style.opacity = '1';
                chatContainer.style.visibility = 'visible';
            }
            
            // Update user display
            const currentUserEl = document.getElementById('current-user');
            if (currentUserEl && user.username) {
                currentUserEl.textContent = user.username;
            }
            
            // Load message history
            loadMessageHistory();
            
            // Setup channel switching
            const channelItems = document.querySelectorAll('#channels-list .list-item');
            channelItems.forEach(item => {
                item.addEventListener('click', function() {
                    // Update active channel UI
                    channelItems.forEach(chan => chan.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update chat title
                    const channelName = this.getAttribute('data-channel');
                    document.getElementById('chat-title').textContent = channelName;
                    
                    // Update message input placeholder
                    document.getElementById('message-input').placeholder = `Message #${channelName}`;
                    
                    // Load messages for the selected channel
                    loadMessageHistory(channelName);
                });
            });
            
            // Setup send button
            const sendButton = document.getElementById('send-button');
            const messageInput = document.getElementById('message-input');
            const messagesContainer = document.getElementById('messages-container');
            
            if (sendButton && messageInput && messagesContainer) {
                sendButton.addEventListener('click', function() {
                    const messageText = messageInput.value.trim();
                    if (messageText) {
                        // Create simple message element
                        const messageEl = document.createElement('div');
                        messageEl.className = 'message own-message';
                        messageEl.innerHTML = `
                            <div class="message-avatar">
                                <img src="https://cdn.glitch.global/2ac452ce-4fe9-49bc-bef8-47241df17d07/default%20pic.png?v=1746110048911" alt="You">
                            </div>
                            <div class="message-content">
                                <div class="message-header">
                                    <span class="message-author">${user.username}</span>
                                    <span class="message-timestamp">Just now</span>
                                </div>
                                <div class="message-text">
                                    ${messageText}
                                </div>
                            </div>
                        `;
                        
                        messagesContainer.appendChild(messageEl);
                        messageInput.value = '';
                        
                        // Scroll to bottom
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        
                        // If socket is connected, send message
                        if (window.socket && window.socket.connected) {
                            const activeChannel = document.querySelector('#channels-list .list-item.active');
                            const channelName = activeChannel ? activeChannel.getAttribute('data-channel') : 'general';
                            
                            window.socket.emit('send-message', {
                                content: messageText,
                                channel: channelName,
                                timestamp: new Date().toISOString(),
                                sender_id: user.id || 'debug-user'
                            }, (response) => {
                                if (response && !response.success) {
                                    console.error('Error sending message:', response.message);
                                    alert('Failed to send message: ' + response.message);
                                } else {
                                    console.log('Message sent successfully');
                                }
                            });
                        }
                    }
                });
                
                // Allow Enter key to send message
                messageInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendButton.click();
                    }
                });
            }
            
            // Set up emoji button to show a simple message
            const emojiButton = document.getElementById('emoji-button');
            if (emojiButton) {
                emojiButton.addEventListener('click', function() {
                    alert('Emoji picker is disabled in debug mode');
                });
            }
            
            // Set up settings button to show settings modal
            const settingsButton = document.getElementById('settings-button');
            if (settingsButton) {
                settingsButton.addEventListener('click', function() {
                    // Create settings modal if it doesn't exist
                    if (!document.getElementById('settings-modal')) {
                        createSettingsModal(user);
                    }
                    
                    // Show the settings modal
                    const settingsModal = new bootstrap.Modal(document.getElementById('settings-modal'));
                    settingsModal.show();
                });
            }
            
            // Set up logout button
            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to log out?')) {
                        localStorage.removeItem('user');
                        localStorage.removeItem('auth_token');
                        window.location.reload();
                    }
                });
            }
            
            // Set up socket message listeners
            if (window.socket) {
                // Clean up any existing listeners to prevent duplicates
                window.socket.off('message');
                window.socket.off('message-history');
                
                window.socket.on('message', function(message) {
                    console.log('Received new message:', message);
                    addMessageToUI(message);
                    
                    // Add to local storage for backup
                    try {
                        const activeChannel = document.querySelector('#channels-list .list-item.active');
                        const channelName = activeChannel ? activeChannel.getAttribute('data-channel') : 'general';
                        const key = 'messages_' + channelName;
                        const storedMessages = JSON.parse(localStorage.getItem(key) || '[]');
                        storedMessages.push(message);
                        localStorage.setItem(key, JSON.stringify(storedMessages));
                    } catch (e) {
                        console.error('Error updating local storage with new message:', e);
                    }
                });
                
                window.socket.on('message-history', function(data) {
                    console.log('Received message history:', data);
                    if (data && data.messages) {
                        console.log(`Received ${data.messages.length} messages for channel ${data.channel}`);
                        displayMessageHistory(data.messages);
                    } else if (data && Array.isArray(data)) {
                        console.log(`Received ${data.length} messages in array format`);
                        displayMessageHistory(data);
                    } else {
                        console.error('Received invalid message history format:', data);
                    }
                });
                
                // Handle channel-messages event (new format)
                window.socket.on('channel-messages', function(data) {
                    console.log('Received channel messages:', data);
                    if (data && data.messages) {
                        console.log(`Received ${data.messages.length} messages for channel ${data.channel}`);
                        displayMessageHistory(data.messages);
                    } else if (data && Array.isArray(data)) {
                        console.log(`Received ${data.length} messages in array format`);
                        displayMessageHistory(data);
                    } else {
                        console.error('Received invalid channel messages format:', data);
                    }
                });
                
                // Handle supabase messages separately if available
                window.socket.on('supabase-messages', function(messages) {
                    console.log('Received Supabase messages:', messages ? messages.length : 0, 'messages');
                    displayMessageHistory(messages);
                });
            }
        }
        
        // Function to load message history
        function loadMessageHistory(channel = 'general') {
            const messagesContainer = document.getElementById('messages-container');
            if (!messagesContainer) return;
            
            // Clear existing messages except the welcome message
            const welcomeMessage = messagesContainer.querySelector('.system-message:first-of-type');
            const dateSeparator = messagesContainer.querySelector('.date-separator:first-of-type');
            messagesContainer.innerHTML = '';
            
            if (dateSeparator) messagesContainer.appendChild(dateSeparator.cloneNode(true));
            if (welcomeMessage) messagesContainer.appendChild(welcomeMessage.cloneNode(true));
            
            // Add loading indicator with ID so we can remove it later
            const loadingId = 'loading-message-' + Date.now();
            const loadingMsg = document.createElement('div');
            loadingMsg.id = loadingId;
            loadingMsg.className = 'system-message';
            loadingMsg.textContent = 'Loading messages...';
            messagesContainer.appendChild(loadingMsg);
            
            // Try to fetch messages directly from Supabase REST API first
            fetchSupabaseMessages(channel)
                .then(supabaseMessages => {
                    const loadingElement = document.getElementById(loadingId);
                    if (loadingElement) {
                        if (supabaseMessages && supabaseMessages.length > 0) {
                            loadingElement.textContent = 'Loaded messages from Supabase';
                            setTimeout(() => loadingElement.remove(), 1000);
                            displayMessageHistory(supabaseMessages);
                            return true; // Successfully loaded from Supabase
                        }
                    }
                    return false; // Couldn't load from Supabase
                })
                .catch(error => {
                    console.error('Error fetching from Supabase:', error);
                    return false; // Error loading from Supabase
                })
                .then(loadedFromSupabase => {
                    // If we didn't load from Supabase, try socket.io
                    if (!loadedFromSupabase && window.socket && window.socket.connected) {
                        console.log('Requesting message history from socket for channel:', channel);
                        window.socket.emit('get-channel-messages', { 
                                    channel: channel,
                                    limit: 50,
                                    offset: 0,
                                    isInitialLoad: true
                                });
                        
                        // Set timeout to remove loading message if no response
                        setTimeout(() => {
                            const loadingElement = document.getElementById(loadingId);
                            if (loadingElement) {
                                // Try to load from local storage if available
                                const localMessages = getLocalMessages(channel);
                                if (localMessages && localMessages.length > 0) {
                                    loadingElement.textContent = 'Loaded messages from local storage';
                                    setTimeout(() => loadingElement.remove(), 1000);
                                    displayMessageHistory(localMessages);
                                } else {
                                    loadingElement.textContent = 'No messages available for this channel';
                                    setTimeout(() => loadingElement.remove(), 2000);
                                }
                            }
                        }, 5000);
                    } else if (!loadedFromSupabase) {
                        // If socket not connected and Supabase failed, try local storage
                        const localMessages = getLocalMessages(channel);
                        const loadingElement = document.getElementById(loadingId);
                        
                        if (localMessages && localMessages.length > 0 && loadingElement) {
                            loadingElement.textContent = 'Loaded messages from local storage';
                            setTimeout(() => loadingElement.remove(), 1000);
                            displayMessageHistory(localMessages);
                        } else if (loadingElement) {
                            loadingElement.textContent = 'Cannot load messages: All methods failed';
                            setTimeout(() => loadingElement.remove(), 3000);
                        }
                    }
                });
        }
        
        // Function to fetch messages directly from Supabase
        async function fetchSupabaseMessages(channel) {
            console.log('Attempting to fetch messages directly from Supabase for channel:', channel);
            
            try {
                // Skip the server-side API and go directly to Supabase to avoid the 500 error
                return await fetchDirectSupabaseMessages(channel);
            } catch (error) {
                console.error('Error fetching messages from Supabase:', error);
                return [];
            }
        }
        
        // Direct Supabase fetch function
        async function fetchDirectSupabaseMessages(channel) {
            console.log('Attempting direct Supabase fetch for channel:', channel);
            
            try {
                // Get auth token from local storage (optional)
                const authToken = localStorage.getItem('auth_token');
                
                // Use the globally defined Supabase credentials
                const supabaseUrl = window.SUPABASE_URL;
                let apiKey = window.SUPABASE_SERVICE_KEY || window.SUPABASE_KEY || window.SUPABASE_ANON_KEY;
                
                console.log('Using Supabase URL:', supabaseUrl);
                
                // Normalize channel name (remove # if present)
                const formattedChannel = channel.startsWith('#') ? channel.substring(1) : channel;
                console.log('Fetching messages for channel:', formattedChannel);
                
                // First, try with the service key for admin access
                const response = await fetch(`https://${supabaseUrl}/rest/v1/messages?channel=eq.${encodeURIComponent(formattedChannel)}&order=created_at.asc.nullslast&limit=100`, {
                    method: 'GET',
                    headers: {
                        'apikey': apiKey,
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Direct Supabase fetch failed: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Direct Supabase messages received:', data.length || 0, 'messages');
                
                // If we got data, format it properly
                if (data && data.length) {
                    // Format messages for consistent display
                    return data.map(msg => ({
                        id: msg.id,
                        content: msg.content || msg.message,
                        sender: msg.sender || msg.username || 'User',
                        sender_id: msg.sender_id || msg.user_id,
                        timestamp: msg.created_at || msg.timestamp,
                        channel: msg.channel
                    }));
                }
                
                // If no data, try without the # prefix
                if (!data || !data.length) {
                    console.log('No messages found with # prefix, trying without prefix');
                    return await fetchSupabaseWithoutPrefix(channel, apiKey);
                }
                
                return data;
                
            } catch (error) {
                console.error('Error in direct Supabase fetch:', error);
                
                // Try an alternative endpoint format as last resort
                try {
                    console.log('Trying alternative Supabase endpoint format...');
                    const supabaseUrl = window.SUPABASE_URL;
                    let apiKey = window.SUPABASE_SERVICE_KEY || window.SUPABASE_KEY || window.SUPABASE_ANON_KEY;
                    
                    // Try various formats of the channel name
                    const channelFormats = [
                        '#' + channel,
                        channel,
                        channel.toLowerCase(),
                        '#' + channel.toLowerCase()
                    ];
                    
                    // Try each format
                    for (const channelFormat of channelFormats) {
                        console.log('Trying channel format:', channelFormat);
                        const response = await fetch(`https://${supabaseUrl}/rest/v1/messages?select=*&channel=eq.${encodeURIComponent(channelFormat)}`, {
                            method: 'GET',
                            headers: {
                                'apikey': apiKey,
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        if (data && data.length) {
                            console.log('Found messages with channel format:', channelFormat);
                            return data;
                        }
                    }
                    
                    // If we reach here, no format worked
                    console.log('No messages found with any channel format');
                    return [];
                    
                } catch (e) {
                    console.error('Alternative endpoint also failed:', e);
                    return [];
                }
            }
        }
        
        // Helper function to try fetching without the # prefix
        async function fetchSupabaseWithoutPrefix(channel, apiKey) {
            const supabaseUrl = window.SUPABASE_URL;
            try {
                const response = await fetch(`https://${supabaseUrl}/rest/v1/messages?channel=eq.${encodeURIComponent(channel)}&order=created_at.asc.nullslast&limit=100`, {
                    method: 'GET',
                    headers: {
                        'apikey': apiKey,
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation'
                    }
                });
                
                if (!response.ok) return [];
                
                const data = await response.json();
                console.log('Messages found without # prefix:', data.length || 0);
                return data;
            } catch (error) {
                console.error('Error fetching without prefix:', error);
                return [];
            }
        }
        
        // Function to get messages from local storage
        function getLocalMessages(channel) {
            try {
                const key = 'messages_' + channel;
                const storedMessages = localStorage.getItem(key);
                return storedMessages ? JSON.parse(storedMessages) : [];
            } catch (e) {
                console.error('Error reading local messages:', e);
                return [];
            }
        }
        
        // Function to create settings modal
        function createSettingsModal(user) {
            const modalHtml = `
            <div class="modal fade" id="settings-modal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content bg-dark text-light">
                        <div class="modal-header">
                            <h5 class="modal-title" id="settingsModalLabel">User Settings</h5>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3 text-center">
                                <div class="profile-picture-container position-relative mx-auto" style="width: 100px; height: 100px;">
                                    <img id="profile-picture-preview" src="${user.avatarUrl || user.avatar_url || 'https://cdn.glitch.global/2ac452ce-4fe9-49bc-bef8-47241df17d07/default%20pic.png?v=1746110048911'}" alt="Profile Picture" class="rounded-circle w-100 h-100 object-fit-cover">
                                    <button id="change-profile-picture-btn" class="btn btn-sm btn-primary position-absolute bottom-0 end-0" style="border-radius: 50%; width: 32px; height: 32px; padding: 0;">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                </div>
                                <input type="file" id="profile-picture-input" accept="image/*" style="display: none;">
                            </div>
                            <div class="mb-3">
                                <label for="username-display" class="form-label">Username</label>
                                <input type="text" class="form-control bg-secondary text-light" id="username-display" value="${user.username}" readonly>
                            </div>
                            <div class="mb-3">
                                <label for="status-select" class="form-label">Status</label>
                                <select class="form-select bg-secondary text-light" id="status-select">
                                    <option value="online" ${user.status === 'online' ? 'selected' : ''}>Online</option>
                                    <option value="idle" ${user.status === 'idle' ? 'selected' : ''}>Idle</option>
                                    <option value="dnd" ${user.status === 'dnd' ? 'selected' : ''}>Do Not Disturb</option>
                                    <option value="invisible" ${user.status === 'invisible' ? 'selected' : ''}>Invisible</option>
                                </select>
                            </div>
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="notification-sounds" checked>
                                <label class="form-check-label" for="notification-sounds">Notification Sounds</label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-primary" id="save-settings">Save Changes</button>
                        </div>
                    </div>
                </div>
            </div>
            `;
            
            // Add modal to document
            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHtml;
            document.body.appendChild(modalContainer.firstChild);
            
            // Set up profile picture change functionality
            const profilePictureInput = document.getElementById('profile-picture-input');
            const changeProfilePictureBtn = document.getElementById('change-profile-picture-btn');
            const profilePicturePreview = document.getElementById('profile-picture-preview');
            const saveSettingsBtn = document.getElementById('save-settings');
            
            if (changeProfilePictureBtn && profilePictureInput) {
                changeProfilePictureBtn.addEventListener('click', () => {
                    profilePictureInput.click();
                });
                
                profilePictureInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            profilePicturePreview.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
            
            if (saveSettingsBtn) {
                saveSettingsBtn.addEventListener('click', () => {
                    // Get updated status
                    const newStatus = document.getElementById('status-select').value;
                    
                    // Get updated avatar if changed
                    const newAvatarUrl = profilePicturePreview.src;
                    
                    // Update user object
                    user.status = newStatus;
                    user.avatarUrl = newAvatarUrl;
                    user.avatar_url = newAvatarUrl;
                    
                    // Save to localStorage
                    localStorage.setItem('user', JSON.stringify(user));
                    
                    // Update UI
                    const statusIndicator = document.querySelector('.status-indicator');
                    if (statusIndicator) {
                        statusIndicator.className = `status-indicator status-${newStatus}`;
                    }
                    
                    // Update all message avatars for this user
                    document.querySelectorAll('.message.own-message .message-avatar img').forEach(img => {
                        img.src = newAvatarUrl;
                    });
                    
                    // Emit status change to server if socket connected
                    if (window.socket && window.socket.connected) {
                        window.socket.emit('update-status', { status: newStatus }, (response) => {
                            if (response && response.success) {
                                console.log('Status updated successfully on server');
                            } else {
                                console.error('Failed to update status on server:', response?.message || 'Unknown error');
                            }
                        });
                        
                        // Handle avatar update
                        if (newAvatarUrl && newAvatarUrl !== user.previousAvatarUrl) {
                            window.socket.emit('update-avatar', { avatarUrl: newAvatarUrl }, (response) => {
                                if (response && response.success) {
                                    console.log('Avatar updated successfully on server');
                                    user.previousAvatarUrl = newAvatarUrl;
                                    localStorage.setItem('user', JSON.stringify(user));
                                } else {
                                    console.error('Failed to update avatar on server:', response?.message || 'Unknown error');
                                }
                            });
                        }
                    }
                    
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('settings-modal'));
                    modal.hide();
                    
                    // Show success message
                    alert('Settings saved successfully!');
                });
            }
        }
        
        // Function to display message history
        function displayMessageHistory(messages) {
            const messagesContainer = document.getElementById('messages-container');
            if (!messagesContainer) return;
            
            // Remove loading message if present
            const loadingMessages = messagesContainer.querySelectorAll('[id^="loading-message-"]');
            loadingMessages.forEach(msg => msg.remove());
            
            // Check if we have messages
            if (!messages || messages.length === 0) {
                const noMessagesEl = document.createElement('div');
                noMessagesEl.className = 'system-message';
                noMessagesEl.textContent = 'No messages in this channel yet. Start the conversation!';
                messagesContainer.appendChild(noMessagesEl);
                return;
            }
            
            // Save to local storage for backup
            try {
                const activeChannel = document.querySelector('#channels-list .list-item.active');
                const channelName = activeChannel ? activeChannel.getAttribute('data-channel') : 'general';
                localStorage.setItem('messages_' + channelName, JSON.stringify(messages));
            } catch (e) {
                console.error('Error saving messages to local storage:', e);
            }
            
            // Sort messages by timestamp
            const sortedMessages = messages.sort((a, b) => {
                return new Date(a.timestamp || a.created_at) - new Date(b.timestamp || b.created_at);
            });
            
            // Display each message
            sortedMessages.forEach(message => {
                addMessageToUI(message, false);
            });
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Function to add a message to the UI
        function addMessageToUI(message, scrollToBottom = true) {
            const messagesContainer = document.getElementById('messages-container');
            if (!messagesContainer) return;
            
            // Skip if message is deleted or invalid
            if (message.is_deleted || !message.content) return;
            
            // Create message element
            const messageEl = document.createElement('div');
            messageEl.className = 'message';
            messageEl.dataset.messageId = message.id || Date.now() + Math.random().toString(36).substring(2, 9);
            
            // Check if message already exists to avoid duplicates
            const existingMessage = messagesContainer.querySelector(`[data-message-id="${messageEl.dataset.messageId}"]`);
            if (existingMessage) {
                return; // Skip if already displayed
            }
            
            // Check if this is the current user's message
            const storedUser = localStorage.getItem('user');
            let currentUser = null;
            try {
                currentUser = JSON.parse(storedUser);
            } catch (e) {}
            
            const isOwnMessage = currentUser && 
                (message.sender === currentUser.username || 
                 message.sender_id === currentUser.id || 
                 message.sender_id === currentUser.userId);
                 
            if (isOwnMessage) {
                messageEl.classList.add('own-message');
            }
            
            // Format timestamp
            const timestamp = message.timestamp || message.created_at || new Date().toISOString();
            const formattedTime = formatTimestamp(timestamp);
            
            // Get sender username - try different properties
            let senderName = message.sender || message.username || 'User';
            
            // If we have a sender_id but no sender name, try to resolve it
            if (message.sender_id && (!senderName || senderName === 'User')) {
                // Log that we're trying to resolve the username
                console.log(`Trying to resolve username for sender_id: ${message.sender_id}`);
                
                // Check if we have this user in local storage
                const usersCache = JSON.parse(localStorage.getItem('users_cache') || '{}');
                if (usersCache[message.sender_id]) {
                    senderName = usersCache[message.sender_id].username;
                    console.log(`Found username in cache: ${senderName}`);
                } else {
                    // If not in cache, we'll display the ID for now and try to fetch it
                    senderName = `User ${message.sender_id.substring(0, 5)}...`;
                    
                    // Request username from server if socket is connected
                    if (window.socket && window.socket.connected) {
                        window.socket.emit('get-username', { userId: message.sender_id }, (response) => {
                            if (response && response.success && response.username) {
                                // Update the displayed username
                                const authorSpan = messageEl.querySelector('.message-author');
                                if (authorSpan) {
                                    authorSpan.textContent = response.username;
                                }
                                
                                // Cache the username
                                usersCache[message.sender_id] = { 
                                    username: response.username,
                                    avatar_url: response.avatar_url
                                };
                                localStorage.setItem('users_cache', JSON.stringify(usersCache));
                                
                                // Update avatar if available
                                if (response.avatar_url) {
                                    const avatarImg = messageEl.querySelector('.message-avatar img');
                                    if (avatarImg) {
                                        avatarImg.src = response.avatar_url;
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            // Get avatar URL - try to use the user's avatar if available
            let avatarUrl = 'https://cdn.glitch.global/2ac452ce-4fe9-49bc-bef8-47241df17d07/default%20pic.png?v=1746110048911';
            
            // For own messages, use the current user's avatar
            if (isOwnMessage && currentUser) {
                avatarUrl = currentUser.avatarUrl || 
                           currentUser.avatar_url || 
                           'https://cdn.glitch.global/2ac452ce-4fe9-49bc-bef8-47241df17d07/default%20pic.png?v=1746110048911';
            } else {
                // For other users' messages, try to get their avatar
                const usersCache = JSON.parse(localStorage.getItem('users_cache') || '{}');
                if (message.sender_id && usersCache[message.sender_id] && usersCache[message.sender_id].avatar_url) {
                    avatarUrl = usersCache[message.sender_id].avatar_url;
                } else if (message.avatar_url) {
                    avatarUrl = message.avatar_url;
                }
            }
            
            // Set message content
            messageEl.innerHTML = `
                <div class="message-avatar">
                    <img src="${avatarUrl}" alt="${senderName}">
                </div>
                <div class="message-content">
                    <div class="message-header">
                        <span class="message-author">${senderName}</span>
                        <span class="message-timestamp">${formattedTime}</span>
                        ${message.edited ? '<span class="message-edited-indicator">(edited)</span>' : ''}
                    </div>
                    <div class="message-text">${message.content}</div>
                </div>
                <button class="message-options-btn" aria-label="Message options">
                    <i class="bi bi-three-dots-vertical"></i>
                </button>
                <div class="message-options-menu" style="display: none;">
                    <div class="menu-item reply-option">
                        <span class="menu-item-icon"><i class="bi bi-reply"></i></span>
                        <span class="menu-item-text">Reply</span>
                    </div>
                    ${isOwnMessage ? `
                    <div class="menu-item edit-option">
                        <span class="menu-item-icon"><i class="bi bi-pencil"></i></span>
                        <span class="menu-item-text">Edit Message</span>
                    </div>` : ''}
                    ${isOwnMessage ? `
                    <div class="menu-item danger delete-option">
                        <span class="menu-item-icon"><i class="bi bi-trash"></i></span>
                        <span class="menu-item-text">Delete Message</span>
                    </div>` : ''}
                    <div class="menu-item copy-option">
                        <span class="menu-item-icon"><i class="bi bi-clipboard"></i></span>
                        <span class="menu-item-text">Copy Text</span>
                    </div>
                    <div class="menu-item react-option">
                        <span class="menu-item-icon"><i class="bi bi-emoji-smile"></i></span>
                        <span class="menu-item-text">Add Reaction</span>
                    </div>
                    <div class="menu-item pin-option">
                        <span class="menu-item-icon"><i class="bi bi-pin-angle"></i></span>
                        <span class="menu-item-text">Pin Message</span>
                    </div>
                </div>
            `;
            
            // Add to container
            messagesContainer.appendChild(messageEl);
            
            // Scroll to bottom if needed
            if (scrollToBottom) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }
        
        // Helper function to format timestamps
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            
            if (isToday) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else {
                return date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + 
                       ' at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
        }
        
        // Message Options Menu Functionality
        document.addEventListener('click', function(event) {
            // Close any open menus when clicking elsewhere
            if (!event.target.closest('.message-options-btn') && !event.target.closest('.message-options-menu')) {
                document.querySelectorAll('.message-options-menu').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
            
            // Toggle menu when clicking the three dots button
            if (event.target.closest('.message-options-btn')) {
                const button = event.target.closest('.message-options-btn');
                const menu = button.nextElementSibling;
                
                // Close all other menus first
                document.querySelectorAll('.message-options-menu').forEach(m => {
                    if (m !== menu) m.style.display = 'none';
                });
                
                // Toggle this menu
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
                event.stopPropagation();
            }
            
            // Handle menu item clicks
            if (event.target.closest('.menu-item')) {
                const menuItem = event.target.closest('.menu-item');
                const message = menuItem.closest('.message');
                const messageId = message.dataset.messageId;
                const messageText = message.querySelector('.message-text').textContent;
                
                // Reply to message
                if (menuItem.classList.contains('reply-option')) {
                    // Set reply mode and focus input
                    const messageInput = document.getElementById('message-input');
                    if (messageInput) {
                        messageInput.value = `> ${messageText}\n\n`;
                        messageInput.focus();
                        messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    }
                }
                
                // Edit message
                if (menuItem.classList.contains('edit-option')) {
                    // Create edit box if it doesn't exist
                    if (!message.querySelector('.message-edit-container')) {
                        const messageContent = message.querySelector('.message-content');
                        const messageTextEl = message.querySelector('.message-text');
                        
                        // Create edit container
                        const editContainer = document.createElement('div');
                        editContainer.className = 'message-edit-container';
                        editContainer.innerHTML = `
                            <textarea class="message-edit-input">${messageText}</textarea>
                            <div class="message-edit-actions">
                                <button class="edit-btn save">Save</button>
                                <button class="edit-btn cancel">Cancel</button>
                                <span class="edit-tip">Press Esc to cancel, Enter to save</span>
                            </div>
                        `;
                        
                        // Insert after message content
                        messageContent.parentNode.insertBefore(editContainer, messageContent.nextSibling);
                        
                        // Focus the textarea
                        const textarea = editContainer.querySelector('.message-edit-input');
                        textarea.focus();
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                        
                        // Handle keyboard shortcuts
                        textarea.addEventListener('keydown', function(e) {
                            if (e.key === 'Escape') {
                                // Cancel edit
                                editContainer.remove();
                            } else if (e.key === 'Enter' && !e.shiftKey) {
                                // Save edit
                                e.preventDefault();
                                saveEdit(messageId, textarea.value);
                            }
                        });
                        
                        // Handle save button
                        editContainer.querySelector('.edit-btn.save').addEventListener('click', function() {
                            saveEdit(messageId, textarea.value);
                        });
                        
                        // Handle cancel button
                        editContainer.querySelector('.edit-btn.cancel').addEventListener('click', function() {
                            editContainer.remove();
                        });
                    }
                }
                
                // Delete message
                if (menuItem.classList.contains('delete-option')) {
                    if (confirm('Are you sure you want to delete this message?')) {
                        deleteMessage(messageId);
                    }
                }
                
                // Copy message text
                if (menuItem.classList.contains('copy-option')) {
                    navigator.clipboard.writeText(messageText)
                        .then(() => {
                            // Show a small notification
                            const notification = document.createElement('div');
                            notification.textContent = 'Copied to clipboard!';
                            notification.style.position = 'fixed';
                            notification.style.bottom = '20px';
                            notification.style.right = '20px';
                            notification.style.backgroundColor = 'var(--success-color)';
                            notification.style.color = 'white';
                            notification.style.padding = '8px 16px';
                            notification.style.borderRadius = '4px';
                            notification.style.zIndex = '1000';
                            document.body.appendChild(notification);
                            
                            // Remove after 2 seconds
                            setTimeout(() => {
                                notification.remove();
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Could not copy text: ', err);
                        });
                }
                
                // Add reaction (placeholder for now)
                if (menuItem.classList.contains('react-option')) {
                    alert('Reaction feature coming soon!');
                }
                
                // Pin message (placeholder for now)
                if (menuItem.classList.contains('pin-option')) {
                    alert('Pin feature coming soon!');
                }
                
                // Close the menu after action
                menuItem.closest('.message-options-menu').style.display = 'none';
            }
        });
        
        // Function to save edited message
        function saveEdit(messageId, newContent) {
            if (!newContent.trim()) {
                alert('Message cannot be empty');
                return;
            }
            
            // Find the message element
            const messageEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!messageEl) return;
            
            // Update UI first for immediate feedback
            const messageTextEl = messageEl.querySelector('.message-text');
            if (messageTextEl) {
                messageTextEl.textContent = newContent;
            }
            
            // Add edited indicator if not already present
            const messageHeader = messageEl.querySelector('.message-header');
            if (messageHeader && !messageHeader.querySelector('.message-edited-indicator')) {
                const editedIndicator = document.createElement('span');
                editedIndicator.className = 'message-edited-indicator';
                editedIndicator.textContent = '(edited)';
                messageHeader.appendChild(editedIndicator);
            }
            
            // Remove edit container
            const editContainer = messageEl.querySelector('.message-edit-container');
            if (editContainer) {
                editContainer.remove();
            }
            
            // Send to server via socket.io
            if (window.socket && window.socket.connected) {
                window.socket.emit('edit-message', {
                    messageId: messageId,
                    newContent: newContent
                }, function(response) {
                    if (!response || !response.success) {
                        console.error('Failed to edit message:', response ? response.error : 'Unknown error');
                        // Revert UI changes if server update fails
                        if (messageTextEl && response && response.originalContent) {
                            messageTextEl.textContent = response.originalContent;
                        }
                    }
                });
            } else {
                console.error('Socket not connected, cannot edit message');
            }
        }
        
        // Function to delete message
        function deleteMessage(messageId) {
            // Find the message element
            const messageEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!messageEl) return;
            
            // Update UI first for immediate feedback
            messageEl.classList.add('message-deleted');
            const messageTextEl = messageEl.querySelector('.message-text');
            if (messageTextEl) {
                messageTextEl.textContent = 'This message has been deleted.';
            }
            
            // Remove options button and menu
            const optionsBtn = messageEl.querySelector('.message-options-btn');
            const optionsMenu = messageEl.querySelector('.message-options-menu');
            if (optionsBtn) optionsBtn.remove();
            if (optionsMenu) optionsMenu.remove();
            
            // Send to server via socket.io
            if (window.socket && window.socket.connected) {
                window.socket.emit('delete-message', {
                    messageId: messageId
                }, function(response) {
                    if (!response || !response.success) {
                        console.error('Failed to delete message:', response ? response.error : 'Unknown error');
                        // Could revert UI changes here if needed
                    }
                });
            } else {
                console.error('Socket not connected, cannot delete message');
            }
        }
        
        // Add keyboard shortcut for showing message options
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Shift') {
                // Add shift-hover class to all messages
                document.querySelectorAll('.message').forEach(msg => {
                    msg.classList.add('shift-hover');
                });
            }
        });
        
        document.addEventListener('keyup', function(e) {
            if (e.key === 'Shift') {
                // Remove shift-hover class from all messages
                document.querySelectorAll('.message').forEach(msg => {
                    msg.classList.remove('shift-hover');
                });
            }
        });
        
        // Listen for message edited events
        if (window.socket) {
            window.socket.on('message-edited', function(data) {
                const { messageId, newContent, userId, username } = data;
                
                // Find the message element
                const messageEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
                if (!messageEl) return;
                
                // Update the message content
                const messageTextEl = messageEl.querySelector('.message-text');
                if (messageTextEl) {
                    messageTextEl.textContent = newContent;
                }
                
                // Add edited indicator if not already present
                const messageHeader = messageEl.querySelector('.message-header');
                if (messageHeader && !messageHeader.querySelector('.message-edited-indicator')) {
                    const editedIndicator = document.createElement('span');
                    editedIndicator.className = 'message-edited-indicator';
                    editedIndicator.textContent = '(edited)';
                    messageHeader.appendChild(editedIndicator);
                }
            });
            
            // Listen for message deleted events
            window.socket.on('message-deleted', function(data) {
                const { messageId, userId, username } = data;
                
                // Find the message element
                const messageEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
                if (!messageEl) return;
                
                // Update the message content
                messageEl.classList.add('message-deleted');
                const messageTextEl = messageEl.querySelector('.message-text');
                if (messageTextEl) {
                    messageTextEl.textContent = 'This message has been deleted.';
                }
                
                // Remove options button and menu
                const optionsBtn = messageEl.querySelector('.message-options-btn');
                const optionsMenu = messageEl.querySelector('.message-options-menu');
                if (optionsBtn) optionsBtn.remove();
                if (optionsMenu) optionsMenu.remove();
            });
        }
    </script>
</body>
</html>
